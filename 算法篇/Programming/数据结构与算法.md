[TOC]
# 数据结构与算法

主要从四个方面来学习**数据结构与算法**，分别为**数据结构**部分、**算法思想**部分、**排序算法**部分和**经典算法题目**部分

## 1. 数据结构

### 1.1 树与二叉树

#### 1.1.1 树的定义以及概念

**树**是n(n>=0)个结点的有限集。n=0时称为空树。

在任意一棵非空树中有，

- 有且仅有一个特定的称为根（root）的结点；
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。

> Note: 
>
> 1. n>0时(非空的树)，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。
>
> 2. m>0时(多个子树)，子树的个数没有限制，但它们一定是互不相交的。

下图是一棵示例的树，

![](../../pics/tree.jpg)

下面是树的一些概念，

- 节点的度

  结点拥有的子树数目称为结点的**度**。在上图中，节点D的度为3，节点J的度为0。

- 结点关系

  - 子结点（孩子结点）

    结点子树的根结点为该结点的孩子结点，上图中B为A的子结点。

  - 父节点（双亲结点）

    类似孩子结点，方向相反，上图中A为B的父节点。

  - 兄弟结点

    父节点相同的两个节点互为兄弟结点，上图中B和C互为兄弟结点。

  - 祖先/子孙结点

    基于上面的父子结点，可以定义传递关系，上图中，A为其余所有结点的祖先结点，反过来其余结点为A的子孙结点。

    > 显然祖先结点包含了父节点

  - 叶子结点

    如果某个结点的子节点均为空（度为0），那么该节点称为叶子结点，上图中，G/H/I/J/F五个结点均为叶子结点

  - **分支结点**

    结点度不为0，则该节点为分支结点，可以说除叶子结点外，其余结点均为分支结点

- 路径

  从一个祖先结点到其任何子孙结点都存在一些列边，这样一系列首尾相连的边称为树种的一条**路径**。路径中边的条数称为该路径的**长度**，那么显然有父节点到其子节点的长度为1。上图中，结点B到结点I的路径为（B-D-I）,路径的长度为3。

- 深度/高度/层数

  - 深度

    树中某一结点深度表示从根节点开始至该节点的路径长度，上图中，结点E的深度为3。

  - 高度

    树中某一结点高度表示从该节点出发，至某一个叶节点的最长路径长度，上图中，结点C的高度为2.

  - 层数

    根节点为第一层，往下依次递增。
  
  - 三者关系
  
    树中节点的**最大层数**称之为**树**的**深度**或者**高度**。
  
  > **注意**：从根节点出发计数为0或者1，有不同说法，问题本质相同，提前说明即可，多数算法偏向为后者

#### 1.1.2 二叉树的定义和性质

- 二叉树的定义

  **二叉树**是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

  下图为一颗二叉树，

  ![](../../pics/binary_tree.jpg)

  > **二叉树的特点**
  >
  > - 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
  > - 左子树和右子树是有顺序的，次序不能任意颠倒。
  > - 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
  > - 二叉树只有五种可能的形态，分别为空二叉树、只有根结点、只有根结点和左子树、只有根结点和右子树和两棵子树均有

- 二叉树的性质

  - 层数对应的结点数量

    在非空的二叉树中，第i层最多有2^(i-1)个结点（i>=1）。

  - 树对应的结点数量

    高度（深度）为h的二叉树至多有2^(h)-1个结点（h>=1）。

  - 叶节点个数和度数为2的结点数量关系

    对于任何非空二叉树，如果其叶节点的个数为n1，度数为2的结点个数为n2，那么n1=n2+1。

#### 1.1.3 二叉树三种形态

二叉树的三种形态分别为**满二叉树**、**扩充二叉树**和**完全二叉树**。

- 满二叉树

  如果二叉树中所有**分支结点**的度数都为2，则它成为一棵满二叉树，显然满二叉树是一般二叉树的一个子集。

- 扩充二叉树

  对于二叉树T，加入足够多的新叶节点，使得T的原有结点都变为度数为2的分支结点，得到的二叉树成为T的**扩充二叉树**，扩充二叉树中，新增的结点称为**外部结点**，原T的结点称为**内部结点**。

- 完全二叉树

  对于一棵高度为h的二叉树，如果第一层至第h层的结点都满（也就是说，对所有的1<=i<=h,第i层有2^(i-1)个结点），如果下一层的结点不满，则所有结点在最左边连续排列，空位都在右边，这样的二叉树称为**完全二叉树**。

  下面为完全二叉树的两个性质：

  - 完全二叉树高度

    n个结点的完全二叉树高度为h=|log2(n)|，即为不大于log2(n)的最大整数

  - 完全二叉树的index

    如果n个结点的完全二叉树，从左至右依次从0编号，那么对任意一个结点i（0<=i<=n-1）

    - 序号为0的结点是根节点
    - 对于i>0，其父节点的编号是(i-1)/2
    - 若2*i+1<n，则其左子节点序号为2\*i+1，否则它无左子节点
    - 若2*i+2<n，则其右子节点序号为2\*i+2，否则它无左子节点

    如下图所示

    ![](../../pics/完全二叉树.png)

  > 完全二叉树的一些特点，
  >
  > 1）满二叉树一定是完全二叉树，但反过来不一定成立
  >
  > 2）同样结点数目的二叉树，完全二叉树深度最小。
  >
  > 3）如果结点度为1，则该结点只有左孩子，即没有右子树。
  >
  > 4）上面的第二个性质，使其可以方面的存入一个数组中，直接根据下标找到一个结点的子节点和父节点，建立和线性结构的双向映射

#### 1.1.4 二叉树的遍历

二叉树的遍历主要分为两部分，深度优先遍历和宽度优先遍历。

- 深度优先遍历

  深度优先遍历分为三种不同的方式，先根遍历、中根遍历和后根遍历

  - 前根遍历

    即先遍历根节点，然后遍历左子树和右子树，以***1.1.2***中所示的二叉树为例，前根遍历顺序为ABDGHICEJF

  - 中根遍历

    先遍历左子树，然后遍历根节点和右子树，以***1.1.2***中所示的二叉树为例，中根遍历顺序为GDIHBAEJCF

  - 后根遍历

    先遍历左子树和右子树，最后遍历根节点，以***1.1.2***中所示的二叉树为例，后根遍历顺序为GIHDBJEFCA

- 宽度优先遍历

  宽度优先遍历又称之为**层次顺序遍历**，以***1.1.2***中所示的二叉树为例，层次遍历顺序为ABCDEFGHJI

> 深度优先遍历的递归和非递归的code需要熟练掌握，宽度优先遍历的code同样需要熟练掌握

#### 1.1.5 二叉树的应用

- **哈夫曼树**

  - 定义

    给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为**最优二叉树**，也称为**哈夫曼树**(Huffman tree)。即带权路径长度最短的树）

  - 应用

    基于哈夫曼树对信息进行编码，在数据压缩上有重要应用，提高了传输的有效性。

- **二叉排序树**

  - 定义

    二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。

    具有以下性质的二叉树：

    1. 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
    2. 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
    3. 它的左右子树也分别为二叉排序树。

  - 操作代价

    既可以有较高的**插入**和**删除**效率，并且具备较高的**查找**效率。
    
    - 查找代价
    
      任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。 
      当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。 
    
      但是当插入的元素有序时，其退化为单支结构，此时查找时间复杂度在O(N)
    
    - 插入代价
    
      新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
    
    - 删除代价
    
      当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。
    
    
    **二叉排序树效率总结**，
    
    查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。 
    插入删除操作算法简单，时间复杂度与查找差不多。

- **平衡二叉树**

  二叉排序树一定程度上可以提高搜索效率，但是当原序列有序，例如序列A = {1，2，3，4，5，6}，构造二叉搜索树就是一颗斜树。依据此序列构造的二叉排序树为右斜树，同时二叉树退化成单链表，搜索效率降低为O(n)。

  如下所示，

  ![](../../pics/xieshu.png)

  因此保持树的高度最小，即可保证树的查找效率。如上结构保存为如下图显然提高查询效率，
  
  ![](../../pics/balance_tree.png)
  
  - 定义
  
    平衡二叉树（AVL）是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。*它是**一种高度平衡的二叉排序树***。意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。上图所示即为一棵平衡二叉树。
  
    若定义结点的“平衡因子”  BF（Balance Factor） = 左子树深度 –右子树深度 则：平衡二叉树中所有结点的BF ∈[ -1, 0, 1 ]
  
  - 操作代价
  
    - 查找代价
    
      平衡二叉树是严格平衡的二叉排序树（平衡因子不超过1）。那么查找过程与二叉排序树一样，只是平衡二叉树不会出现最差情况的平衡二叉树(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
    
    - 插入代价
    
      AVL必须要保证严格平衡(|bf|<=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要修正一次即可。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
    
    - 删除代价
    
      AVL删除结点的算法可以参见二叉排序树的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)。
    
    **二叉平衡树效率总结**，
    
    查找的时间复杂度维持在O(logN)，不会出现最差情况 
    AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 
    AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。

> 该部分主要熟悉二叉树的几种应用，明确几种二叉树的定义以及应用场景，明确各自的效率

#### 1.1.6 二叉树的练习题目

- 二叉树的遍历

  - [先根遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

    1 2021.12.30

    1 2020.02.28

    1 2020.04.20（递归+非递归，17min50s）

    1 2020.09.14（递归+非递归）

  - [中根遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

    1 2021.12.30

    1 2020.02.28

    1 2020.04.20（递归+非递归，9min30s）

    1 2020.09.14（递归+非递归）

  - [后根遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

    1 2021.12.30

    1 2020.02.28

    1 2020.04.20（递归+非递归，5min50s）

    1 2020.09.14（递归+非递归）

  - [层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

    1 2021.12.30
    
    1 2020.02.28
    
    1 2020.04.20（递归+非递归，18min50s）
    
    写递归的方法耗时较多
    
    1 2020.09.14

- [ ] [另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree)

  1 2021.01.07（树遍历，非递归）

  1 2021.12.30

  1 2020.02.29

  1 2020.04.20（递归，17min50s）

  1 2020.09.14

- [ ] [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

  1 2021.12.30

  1 2020.02.29

  1 2020.04.20（递归+非递归，12min50s）

  1 2020.09.14（递归）

- [ ] [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths) 

  1 2021.12.30

  1 2021.12.30（用前根遍历思想）

  1 2020.02.29(递归+非递归)

  1 2020.05.03（递归+非递归，21min20s）

- [ ] [二叉树的深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  1 2021.12.30

  1 2020.03.01 (递归+非递归)

  1 2020.05.02（递归+非递归，4min43s）

- [ ] [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)

  1 2021.12.30

  1 2020.03.01 

  1 2020.05.02（4min15s）

- [ ] [相同的树](https://leetcode-cn.com/problems/same-tree)

  1 2021.12.30

  1 2020.02.29

  1 2020.03.01

  1 2020.05.02（1min44s） 

- [ ] [递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree)

  1 2021.12.30

  1 2020.12.30

  1 2020.03.01

  1 2020.05.02（30min） 

- [ ] [叶子相似的树](https://leetcode-cn.com/problems/leaf-similar-trees)

  1 2021.12.30

  1 2020.12.30

  1 2020.03.03

  1 2020.05.02（10min40s，yield学习了）

- [ ] [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)

  1 2021.12.30

  1 2020.03.03(递归+非递归)

  1 2020.05.02（7min15s，perfect）

- [ ] [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree)

  1 2021.12.30

  1 2020.03.03(递归+非递归)

  1 2020.05.02（2min8s）

- [ ] [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees)

  1 2021.12.30

  1 2020.03.01

  1 2020.05.02（3min30s）

- [ ] [二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt)

  1 2021.12.30

  1 2020.03.01

  1 2020.05.02（17min5s，题目意思读错了） 

- [ ] [单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree)

  1 2021.12.30

  1 2020.03.01(递归+非递归)

  1 2020.05.02（8min36s）

- [ ] [从根到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/)

  1 2021.12.30

  1 2020.03.04(递归+非递归)

  1 2020.05.02(12min58s)

- [ ] [左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  1 2021.12.30

  1 2020.03.01(递归+非递归)

  1 2020.05.02(10min45s)

- [ ] [层数最深叶子节点的和](https://leetcode-cn.com/problems/deepest-leaves-sum/)

  1 2021.12.30
  
  1 2020.03.01
  
  1 2020.05.02（5min45s）
  
- [ ] [ 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

  1 2021.12.30

  1 2020.05.02（14min18s）

- [ ] [二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

  1 2021.12.30
  
  1 2020.05.02（44min）
  
- [ ] [ 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

  1 2021.12.30
  
  1 2020.05.03
  
- [ ] [二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

  1 2022.01.07

- [ ] [二叉树的最近公共祖先II](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

  1 2022.01.07

### 1.2 链表

#### 1.2.1 链表定义

用链接关系显式表示元素之间的顺序关系，基于链接技术实现的线性表称为**链接表**或**链表**。

采用链接方式实现线性表的基本思想如下：

- 把表中元素分别存储在一批独立的存储块（**结点**）中。
- 保证从组成表结构中的任一个结点可以找到与其相关的下一个结点。
- 在前一结点里用链接的方式显式地记录与下一个结点之间的关联。

链表的特点：

1.在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续

2.链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址

3.查找数据时效率低,时间复杂度为O(N)

4.空间利用率高，空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高

5.任意位置插入元素和删除元素效率较高，时间复杂度为O(1)

#### 1.2.2 链表的分类

主要分为**单链表**、**循环链表**、**双向链表**和**双向循环链表**。

- 单链表

  在单链表中，与表里的n个元素对应的n个结点通过链接形成一条结点链。显然，要想掌握一个单链表，只需要掌握这个表的首结点，从它出发可以到达其它的结点。这个单链表的首节点称之为**表头变量**或者**表头指针**。

- 循环单链表

  即单链表中，最后一个结点的链接域不是None而是指向表的第一个结点。

- 双向链表

  在单链表的结点中，加入一个前向的引用域来链接前一个元素。

- 双向循环链表

  将双向链表的表首和表尾链接在一起。

#### 1.2.3 链表的操作

操作部分主要包括增加元素、删除元素、修改元素改查和遍历，判断链表是否为空，链表的大小。

- 增

  在链表中增加一个元素，主要考虑表头插入元素，表尾插入元素和一般的插入元素。

- 删

  在链表中删除一个元素，主要考虑删除指定位置的元素，或者删除取值为某个值的元素。

- 改链表中指定位置的元素

- 查找某一元素在链表中是否存在

- 遍历表的元素

- 判断链表是否为空

- 链表的大小

#### 1.2.4 链表的练习题目

- [ ] 将四种链表（单、双、循环、双向）的链表操作（参考**1.2.3 链表操作**部分）分别实现

  > 需要清楚每一种操作的复杂度

- [ ] [反转链表](https://leetcode-cn.com/problems/reverse-linked-list)

  1 2022.01.03

  1 2020.3.8(递归+非递归)

- [ ] [反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii)

  1 2022.01.03

  1 2020.3.8

- [ ] [两数相加](https://leetcode-cn.com/problems/add-two-numbers)

  1 2022.01.03

  1 2020.3.9

- [ ] [环形链表](https://leetcode-cn.com/problems/linked-list-cycle)

  1 2022.01.09

  1 2022.01.03

  1 2020.03.09(哈希表+双指针)

  1 2020.06.14

- [ ] [排序链表](https://leetcode-cn.com/problems/sort-list)

  1 2020.3.13

- [ ] [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

  1 2022.01.09

  1 2022.01.03

  1 2020.03.13

  1 2020.05.19

- [ ] [移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)

  1 2022.01.09

  1 2020.3.12(递归+非递归)

- [ ] [删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)

  1 2022.01.09

  1 2020.03.12

- [ ] [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list) 

  1 2022.01.09

  1 2020.03.12

- [ ] [删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)

  1 2022.01.09（耗时久，未想清楚基本思路）

  1 2020.03.13(递归+非递归)

- [ ] [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)

  1 2022.01.09

  1 2020.3.12

  1 2020.3.13(新思路掌握)

- [ ] [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)

  1 2022.01.09

  1 2020.3.12

- [ ] [链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)

  1 2022.01.09

  1 2020.3.12(快慢指针)

- [ ] [分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts)

  1 2022.01.09
  
  1 2020.3.13

### 1.3 哈希表



### 1.4 数组

#### 1.4.1 数组定义

所谓数组，是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。

数组的特点：

- 在内存中，数组是一块连续的区域

- 数组需要预留空间

  > 在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即数组空间利用率低

- 在数组起始位置处，插入数据和删除数据效率低

  > 插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移
  >
  > 删除数据时，待删除位置后面的所有元素都需要向前搬移

- 随机访问效率很高，时间复杂度可以达到O(1)

  因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了

- 数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移

整体数组的优缺点：

优点：随机访问性强，查找速度快，时间复杂度为O(1)

缺点：

1.头插和头删的效率低，时间复杂度为O(N)

2.空间利用率不高

3.内存空间要求高，必须有足够的连续的内存空间

4.数组空间的大小固定，不能动态拓展

#### 1.4.2 数组和链表的异同

数组的优缺点：

- 数组的优点

  随机访问性强，查找速度快，时间复杂度为O(1)

- 数组的缺点

  1.头插和头删的效率低，时间复杂度为O(N)

  2.空间利用率不高

  3.内存空间要求高，必须有足够的连续的内存空间

  4.数组空间的大小固定，不能动态拓展

链表的优缺点：

- 链表的优点

  1.任意位置插入元素和删除元素的速度快，时间复杂度为O(1)

  2.内存利用率高，不会浪费内存

  3.链表的空间大小不固定，可以动态拓展

- 链表的缺点

  随机访问效率低，时间复杂度为0(N)

综上：

对于想要快速访问数据，不经常有插入和删除元素的时候，选择数组

对于需要经常的插入和删除元素，而对访问元素时的效率没有很高要求的话，选择链表

#### 1.4.3 数组的练习题目

[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

1 2022.01.08

[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

1 2022.01.08

[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

1 2022.01.08

[189. 轮转数组](https://leetcode-cn.com/problems/rotate-array/)
1 2022.01.08

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

1 2022.01.08

[66. 加一](https://leetcode-cn.com/problems/plus-one/)

1 2022.01.08

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

1 2022.01.08

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

1 2022.01.08

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

1 2022.01.08

[6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

1 2022.01.08

## 2. 算法设计模式

### 2.1 动态规划

#### 2.1.1 定义

动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

有关动态规划的思想，可以参考知乎链接[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？](https://www.zhihu.com/question/23995189)

一句话简要概括：动态规划是通过**拆分问题，**定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。

#### 2.1.2 练习题目

- [ ] [最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

  1 2021.12.30

  1 2019.10.27

  1 2020.01.27

  1 2020.04.12（3min15s）

  1 2020.09.14（3min11s）

- [ ] [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

  1 2021.12.30

  1 2019.10.27

  1 2020.01.27

  1 2020.04.12（2min50s）

  1 2020.09.14（3min30s）

- [ ] [不同路径](https://leetcode-cn.com/problems/unique-paths)

  1 2021.12.31

  1 2019.11.9

  1 2020.01.27

  1 2020.04.12（8min50s）

  1 2020.09.14（4min40s）

- [ ] [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii)

  1 2021.12.31

  1 2019.11.9 

  1 2020.01.27

  1 2020.04.12（9min58s）

  1 2020.09.14（11min30s）

- [ ] [打家劫舍](https://leetcode-cn.com/problems/house-robber)

  1 2021.12.31

  1 2019.11.09

  1 2020.02.07

  1 2020.04.13（5min）

- [ ] [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii)

  1 2021.12.31

  1 2019.11.9

  1 2020.02.07 

  1 2020.04.13（6min30s）

- [ ] [零钱兑换](https://leetcode-cn.com/problems/coin-change)

  1 2022.01.13（12min36s，一遍过）

  1 2022.01.01（24min）

  1 2021.12.31

  1 2019.11.12

  1 2020.02.11

  1 2020.04.13（1h）

  1 2020.05.08（16min35s）

  1 2020.05.10（动态规划，完全背包思想）

  1 2020.06.02（动态规划，16min20s）

  1 2020.06.02（完全背包，21min10s）

  1 2020.09.14（动态规划）

- [ ] [零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

  1 2022.01.01

  区别于爬楼梯（排列），可以参考此[解答](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/)

  1 2020.05.10（动态规划，完全背包思想，当时想了好久没有想清楚，老想着约定的套路了，没有仔细定义清楚子问题。）

  1 2020.06.02（背包思想，24min50s）

- [ ] [一和零](https://leetcode-cn.com/problems/ones-and-zeroes)

  1 2022.01.01

  1 2020.02.25

  1 2020.04.18（失败，没有定义清楚问题，耗费及其长的时间）

  1 2020.05.08（失败，还是没有思路来定义这个问题，三维度）

  1 2020.05.10（搞定15min，0-1背包的思想）

  1 2020.06.02（22min50s）

- [ ] [判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

  1 2022.01.01
  
  1 2020.02.25
  
  1 2020.04.18（17min8s）
  
  1 2020.06.03（20min13s）

新添加的题目

- [ ] [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs)

  1 2021.12.30

  1 2019.11.17

  1 2020.02.11

  1 2020.04.18（4min50s）

  1 2020.09.14

- [ ] [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)

  1 2022.01.01

  1 2020.02.26

  1 2020.04.18（25min50s）

  1 2020.06.03（11min10s）

  1 2020.06.03（贪心+二分，nlogn）

- [ ] [预测赢家](https://leetcode-cn.com/problems/predict-the-winner)

  1 2022.01.01

  1 2019.11.24

  1 2020.02.21

  1 2020.04.18（36min40s）

  1 2020.06.03（27min55s）

- [ ] [目标和](https://leetcode-cn.com/problems/target-sum)

  1 2022.01.03（01背包）

  1 2019.11.17

  1 2020.02.23

  1 2020.04.18（22min50s）

  1 2020.05.10（之前写的存在问题，虽然AC但是本质不是动态规划的，相当于暴力解决，目前已经通过动态规划解决，已可以理解为0-1背包问题）

  1 2020.06.03（14mind50s，暴力解决）

- [ ] [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)

  1 2022.01.03（动态规划、暴力+剪枝）

  1 2019.11.24

  1 2020.02.12

  1 2020.02.25

  1 2020.04.18（15min20s）

  1 2020.05.25（14min30s）

- [ ] [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)

  1 2022.01.03

  1 2020.02.25

  1 2020.04.18（27min40s）

  1 2020.05.25（24min33s）

- [ ] [最长公共子串](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

  1 2022.01.03

  1 2020.02.25

  1 2020.04.18（27min25s）

  1 2020.05.25（8min15s）

  1 2020.09.17 

- [ ] [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

  1 2022.01.03

  1 2020.02.25

  1 2020.04.18（7min）

  1 2020.05.25（7min39s）

  1 2020.09.17 

- [ ] [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

  1 2022.01.03

  1 2020.02.26

  1 2020.04.18（6min39s）

股票类题目总体解答：[一种方式团灭股票](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-wen-ti-by-chen-wei-f-gc4k/)

- [ ] [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)-难度1

  1 2022.01.03

  1 2019.11.17

  1 2020.02.11

  1 2020.04.18（4min45s）

  1 2020.06.03（4min30s）

- [ ] [买卖股票最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)-难度2

  1 2022.01.03

  1 2020.04.19（超时）

  1 2020.06.03（8min，直观定义求解）

- [ ] [ 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)-难度3

  1 2020.04.19（未做出）

  1 2020.06.14（未定义出状态，参考定义成功写出转移方程和代码）

- [ ] [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)-难度4

  1 2020.04.19（搞定）

  1 2020.06.14（和上面一个题目写的一个通解）

- [ ] [买卖股票冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)-难度2

  1 2020.02.26

  1 2020.04.18（45min55s，基本失败）

  1 2020.04.19

  [解题思路](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/tong-su-yi-dong-de-dong-tai-gui-hua-jie-fa-by-marc/)

- [ ] [买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)-难度2

  1 2020.04.19

- [ ] [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

  1 2022.01.03
  
  1 2020.02.27
  
  1 2020.04.19（30min）
  
- [ ] [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

  1 2022.01.03
  
  1 2020.04.11
  
  1 2020.04.19（39min30s）
  
- [ ] [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

  1 2022.01.03

  1 2020.03.24
  
  1 2020.04.19（22min30s）
  
- [ ] [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

  1 2022.01.03
  
  1 2020.05.21
  
- [ ] [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

  0 2022.01.03

  1 2020.05.23

- [ ] [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

  1 2020.05.25（好难啊）

### 2.2 分治法

#### 2.2.1 定义

把复杂问题分解为相对简单的子问题，分别求解，最后通过组合起子问题的解的方式得到原始问题的解。

#### 2.2.2 练习题目



### 2.3 贪心法

#### 2.3.1 定义

根据问题的信息尽可能做出部分的解（局部最优），并基于部分解逐步扩充得到完整的解（基于局部最优得到全局最优），需要注意的是，在复杂问题下，有可能这种局部的解并不是全局最优的解。

#### 2.3.2 练习题目

- [分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

  1 2020.4.6

- [判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

  1 2020.4.6
  
- [柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

  1 2020.4.7

### 2.4 回溯法

#### 2.4.1 定义

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，**这种走不通就退回再走的技术为回溯法**，而满足回溯条件的某个状态的点称为 “回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

#### 2.4.2 练习题目

- [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

  1 2022.01.05（注意复杂度的是多少）

  1 2020.05.28

  1 2020.09.18 

- [46. 全排列](https://leetcode-cn.com/problems/permutations/)

  1 2022.01.05
  
  1 2020.05.28
  
  1 2020.09.18 （两种方式，1.指针滑动 2.数组缩减）
  
- [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

  1 2022.01.05（注意和上面的轻微的差异）

  1 2020.05.30（两种dfs方式）

  1 2020.09.18 

- [78. 子集](https://leetcode-cn.com/problems/subsets/)

  1 2022.02.05

- [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

  1 2022.02.05

- [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

  1 2022.02.05

- [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

  1 2022.02.05

- [括号](https://leetcode-cn.com/problems/bracket-lcci/)

  1 2022.01.05
  
  1 2020.05.30
  
  1 2020.09.18 
  
  1 2022.01.06
  
  1 2022.02.05

### 2.5 分支限界法



### 2.6 枚举法



## 3. 算法实现方式

### 3.1 递归

#### 3.1.1 定义

递归（recursion）是指函数/过程/子程序在运行过程序中直接或间接调用自身而产生的重入现像。

程序调用自身的编程技巧称为递归。

- 递归就是在过程或函数里调用自身
- 在使用递增归策略时，必须有一个明确的**递归结束条件**，称为递归出口。

![](../../pics/recur.jpg)

递归算法一般用于解决三类问题，

- 数据的定义是按递归定义的，eg. Fibonacci函数
- 问题解法按递归算法实现，eg. 回溯
- 数据的结构形式是按递归定义的。(树的遍历，图的搜索)

**递归算法的缺点**，

递归算法解题的运行效率较低。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。

#### 3.1.2 练习题目

首先按照该[链接](http://39.96.217.32/blog/4#comment-container)内容将递归的知识详细的过一遍，然后进行下面的练习题。

> 可能会有一些题目和上面存在重复，主要是以**递归的思维**求解这些题目，及时做出总结

以下题目需要使用递归解决，

- [ ] [最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path)

  1 2020.3.4(好题目，动态规划+递归，定义清楚问题来拆解)

- [ ] [二叉搜索树结点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes)

  1 2020.3.4(未做出来当时)

- [ ] [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

  1 2020.3.5

- [ ] [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)

  1 2020.3.5

- [ ] [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)

  1 2020.3.5

- [ ] [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)

  1 2020.3.6

- [ ] [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees)

  1 2020.3.5

- [ ] [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree)

  1 2020.3.5

- [ ] [路径总和](https://leetcode-cn.com/problems/path-sum)

  1 2020.3.5

- [ ] [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii) 

  1 2020.3.5

- [ ] [另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree)

  1 2020.3.5 
  
- [ ] [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

  1 2020.05.15

### 3.2 双指针

#### 3.2.1 定义

定义两个指针，进行滑动求解。核心的第一步要想到用这种方式，其次定义好如何进行滑动动即可。

#### 3.2.2 练习题目

- [和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

  1 2022.01.04
  
  1 2020.04.10
  
  1 2020.09.17
  
- [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

  1 2022.01.16

- [三数之和](https://leetcode-cn.com/problems/3sum/)

  1 2021.01.08

  1 2020.05.04

- [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

  1 2020.05.04

- [四数之和](https://leetcode-cn.com/problems/4sum/)

  1 2020.05.04（n sum）

- [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

  1 2020.05.05
  
  1 2022.01.23
  
- [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

  1 2020.05.24（不太算是双指针）

### 3.3 二分查找

#### 3.3.1 定义

每次折半的方式进行元素的查找

#### 3.3.2 练习题目

- [二分查找](https://leetcode-cn.com/problems/binary-search/)

  1 2022.01.04

  1 2020.05.04 （非递归3min12s；递归3min20s）

  1 2020.09.17 

- [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

  1 2022.01.04

  1 2020.05.14

  1 2020.05.19

  1 2020.09.19 

- [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

  1 2022.01.13

- [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

  1 2022.01.04

  1 2020.05.04（递归二分59min；路径法快一些，没有想到）

- [I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

  1 2022.01.04

  1 2020.05.04（13min，使用左边界和有边界解决）

  1 2020.09.17 

- [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

  1 2022.01.04（和上面的题目基本一样）

  1 2020.05.09

  1 2020.09.17 

- [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

  1 2022.01.04

  1 2020.05.09

- [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

  1 2022.01.20

- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

  1 2022.01.04
  
  1 2020.05.23
  
- [寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

  1 2020.05.10 （耗时很久，整体思路清晰，但是细节没有理清楚）

### 3.4 搜索方式

深度优先(dfs)和宽度优先(bfs)

#### 3.4.1 深度优先搜索

两者算法的思想：

深度优先可以这样想，一个人迷路，遇到很多分叉路口，他只有一个人，并且想走出去，所以只能一个个尝试，一条道路走到黑，发现到头了，然后再拐回去走刚才这条路的其他分叉路口，最后发现这条路的所有分叉路口走完了，选择另外一条路继续以上操作，直到所有的路都走过了。

广度优先并不是这样，一个人迷路，但是他有技能（分身术）它遇到分叉路口，不是选一个走，而是分身多个人都试试，比如有A、B、C三个分叉路口，它A路走一步，紧接着B路也走一步，然后C路也赶紧走一步，步伐整齐统一，直到所有的路走过了。

所以说，深搜往往用于解决连通性的问题，而广搜则多用于求解最短路径。
- [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

  1 2022.01.04
  
  0 2020.05.23
  
  1 2020.05.30
  
- [[1391. 检查网格中是否存在有效路径](https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/)]

  1 2022.01.04（定义子问题）

  1 2020.05.31

- [[16.19. 水域大小](https://leetcode-cn.com/problems/pond-sizes-lcci/)]

  1 2022.01.04
  
  1 2020.06.01
  
- [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

  1 2022.01.18

#### 3.4.2 广度优先搜索



### 3.5 位运算

###  

## 4. 排序算法

[leetcode排序测试题目](https://leetcode-cn.com/problems/sort-an-array/)

[179. 最大数](https://leetcode-cn.com/problems/largest-number/)

### 4.1 快速排序

1 2021.12.31

1 2020.03.07

1 2020.03.28

1 2020.04.04

1 2020.05.02(6min25s)

1 2020.05.19

1 2020.09.17 

时间复杂度分析：

- 最好时间复杂度

  每次都恰好五五分，一次递归共需比较n次，递归深度为$\log n$，所以时间复杂度是$n \log n$

- 最坏时间复杂度

  数据完全是倒序，这样需要比较$n+n-1+n-2+\cdots+1=\frac{1}{2} n(n-1) \sim n^2$.

- 平均时间复杂度

  需要一些递推式，就不细究了，平均复杂度也为$n \log n$.

空间复杂度分析：

主要是递归造成的栈空间的使用，最好情况，递归树的深度为$\log n$，其复杂度也为$\log n$。最坏的情况需要进行n‐1递归调用，其空间复杂度为O(n)，平均的空间复杂度也为O(logn)。

稳定性：不稳定

### 4.2 冒泡排序

1 2022.01.06（两种方式）

1 2020.03.08

1 2020.03.27（三种方式实现）

1 2020.04.04（三种方式实现）

1 2020.05.02（三种实现，9min35s）

**基本思想:** 

冒泡排序，类似于水中冒泡，较大的数沉下去，较小的数慢慢冒起来，假设从小到大，即为较大的数慢慢往后排，较小的数慢慢往前排。

目前了解到两种表达方式：

1. 个人比较常用的

   类似打擂台的方式，每次找到最小的数字，放在最左侧

2. 冒泡方式

   每次相邻的数字两两比较，将大的数字最终"冒"到最右侧（亦或是将最小的数字"冒"到最左侧）

算法复杂度分析：

平均复杂度：O(n2)

最好复杂度：O(n)

最坏复杂度：O(n2)

空间复杂度：O(1)

稳定性：稳定

###  4.3 选择排序

1 2022.01.06

1 2020.03.08

1 2020.03.27

1 2020.04.04

1 2020.05.02（4min25s）

类似上面冒泡排序中第一种方式，每次找到最小的数字之后，然后再两两交换，不是每次都两两交换。

算法复杂度分析：

平均复杂度：O(n2)

最好复杂度：O(n2)

最坏复杂度：O(n2)

空间复杂度：O(1)

稳定性： 不稳定

### 4.4 插入排序

1 2022.01.06（延迟一段时间）

1 2020.03.08 

1 2020.03.27

1 2020.04.04

1 2020.05.02（4min19s）

类似打扑克排牌的方式进行，每次在有序的序列中插入一个数字，使得之后的序列仍然是一个有序的序列。

算法复杂度分析：

平均复杂度：O(n2)

最好复杂度：O(n)

最坏复杂度：O(n2)

空间复杂度：O(1)

稳定性：稳定

### 4.5 归并排序

1 2022.01.06

1 2020.03.08(递归+**非递归**，未实现)

1 2020.03.27(递归)

1 2020.04.04(递归)

1 2020.05.02(递归，19min50s)

```python
# 归并排序，非递归版本
def merge(seq, low, mid, high):
    left = seq[low: mid]
    right = seq[mid: high]
    k = 0 
    j = 0
    result = []
    while k < len(left) and j < len(right):
        if left[k] <= right[j]:
            result.append(left[k])
            k += 1
        else:
            result.append(right[j])
            j += 1
    result += left[k:]
    result += right[j:]
    seq[low: high] = result

def merge_sort(seq):
    i = 1 # i是步长
    while i < len(seq):
        low = 0
        while low < len(seq):
            mid = low + i #mid前后均为有序
            high = min(low+2*i,len(seq))
            if mid < high: 
                merge(seq, low, mid, high)
            low += 2*i
        i *= 2
```

算法思想：合并两个有序的序列。

算法复杂度分析：

平均复杂度：O(nlogn)

最好复杂度：O(nlogn)

最坏复杂度：O(nlogn)

空间复杂度：O(n)

稳定性： 稳定

### 4.6 堆排序

1 2022.01.06

1 2020.03.11

1 2020.03.27

1 2020.04.04

1 2020.05.02（24min40s）

算法思想：不断的重建堆，弹出最大元素。

算法复杂度：

平均复杂度：O(nlogn)

最好复杂度：O(nlogn)

最坏复杂度：O(nlogn)

空间复杂度：O(1)

稳定性：不稳定

## 5. 经典算法题目

### 5.1 TOP N

[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

1 2022.01.06

1 2020.03.13

1 2020.05.02（小顶堆，45min；大顶堆，7min）

方案1：快排取index为k，时间复杂度，NlogN，空间复杂度O（1），不可取

方案2：所有元素构建一个大顶堆，然后弹出k个堆顶，时间复杂度klogN，空间复杂度O(1)

方案3：维护一个k大小的小顶堆，然后遍历所有元素，时间复杂度Nlogk，空间复杂度O(k)（目前此方案是最快）

方案4：快排思想，每次删减部分元素，平均时间复杂度O（N），空间复杂度O（1）

### 5.2 接雨水

[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

1 2020.05.05

[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

1 2020.05.05

### 5.3 蓄水池抽样

相关理论：



- [抽一个样本](https://leetcode-cn.com/problems/linked-list-random-node/)

  1 2020.05.05

- [随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

  1 2020.05.05

### 5.4 背包问题

参考资料：

[leet总结](https://leetcode-cn.com/problems/coin-change/solution/yong-bei-bao-wen-ti-si-xiang-lai-li-jie-ying-bi-zh/)

[知乎总结](https://zhuanlan.zhihu.com/p/85780471?from_voters_page=true)

#### 5.4.1 0-1背包问题

一个小偷面前有一堆（n个）财宝，每个财宝有重量`w`和价值`v`两种属性，而他的背包只能携带一定重量的财宝（Capacity），在已知所有财宝的重量和价值的情况下，如何选取财宝，可以最大限度的利用当前的背包容量，取得最大价值的财宝（或求出能够获取财宝价值的最大值）。

定义我们的状态转移方程

dp\[i\]\[k]为前i个财宝在容量为k下能够获取的最大价值，最中的答案即为，dp\[n]\[C]

转移方程为：
$$
dp[i][k] = \min
\begin{cases}
dp[i-1][k],\quad 第i个物品不选择 \\
v[i]+dp[i-1][k-w[i]], \quad 第i个物品选择，且k \geq w[i]
\end{cases}
$$

- [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

  1 2020.05.10

  1 2020.05.26（23min14s，问题定义不够清晰，写代码有卡顿）

- [一和零](https://leetcode-cn.com/problems/ones-and-zeroes)

  1 2020.05.10

- [目标和](https://leetcode-cn.com/problems/target-sum)

  1 2020.05.10（动态规划中有此题目）

#### 5.4.2 完全（无界）背包问题

如果不限定每种物品的数量，同一样物品想拿多少拿多少，则问题称为无界或完全背包问题。

> 上面的问题相当于是最多拿1次，即拿或者不拿

定义我们的状态转移方程

dp\[i\]\[k]为前i个财宝在容量为k下能够获取的最大价值，最中的答案即为，dp\[n]\[C]

转移方程为：
$$
dp[i][k] = \min
\begin{cases}
dp[i-1][k],\quad 第i个物品不选择 \\
v[i]+dp[i][k-w[i]], \quad 第i个物品选择，且k \geq w[i]
\end{cases}
$$

> 对比0-1背包，状态的定义的最大价值中已经包含了可以任意次的选取。所以核心的不同就是就是第个物品如果选择后，回溯值时是否考虑当前物品。

- [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

  1 2020.05.10（动态规划中有此题目）

- [零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

  1 2020.05.10（动态规划中有此题目）

#### 5.4.3 多重（有界）背包问题

如果限定物品`i`最多只能拿`m[i]`个，则问题称为有界或多重背包问题。

转换为0-1背包问题，多加一层循环，每个物品的次数进行判断。

#### 5.4.4 混合背包

如果物品中既有最多只能拿`m[i]`个物品，又有不限数量的物品，又有只有一件的物品，我们该如何选取呢？

整体思路和上面类似，此时将以上三类背包抽象为固定函数，**依次遍历物品**更新dp即可。

### 5.5 合并K sorted序列



### 5.6 木棍最多覆盖点的数量

给定数轴上的n个点的坐标，以及一根长度为L的木棍，求最多覆盖的点数量。

```python
def cover_points(nums, L):
    if not nums or L == 0: return 0
    if len(nums) == 1: return 1
    left, right = 0, len(nums)-1
    if nums[right] - nums[left] <= L:
        return right-left+1
    else:
        return max(cover_points(nums[left+1:right+1], L),
                   cover_points(nums[left:right], L))
```

```python
def cover_points(nums, L):
    if not nums or L == 0: return 0
    if len(nums) == 1: return 1
    s, e = 0, 1
    ret = 1
    while 0 <= s < e <= len(nums)-1:
        if nums[e] - nums[s] <= L:
            ret = max(ret, e-s+1)
            e += 1
        else:
            s += 1
    return ret
```



## 6. 剑指offer

#### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

1 2022.01.08

1 2020.09.16 

#### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

1 2022.01.09

12020.09.16 

#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

1 2022.01.09

1 2020.09.16 

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

1 2022.01.13 

1 2022.01.09 （需要想清楚判断的逻辑，谷顶和谷底，结合153）

1 2020.09.16 

[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

1 2022.01.09 

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

1 2022.01.10

1 2022.01.06（注意时间复杂度和空间复杂度的计算）

1 2020.09.16 

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

1 2022.01.13（两个思路，动态规划+深度优先遍历）

1 2020.09.16 

#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

1 2022.01.11（注意证明）

1 2020.09.16 

#### [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

1 2022.01.11（注意简便方法）

1 2020.09.16 

#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

1 2022.01.11（注意总结-位运算）

1 2020.09.16 

#### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

1 2022.01.13

1 2020.09.17 

#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

1 2022.01.13（大数解决）

难，未作出，参考链接[1全排列/2大数相加](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1dao-zui-da-de-nwei-1-8/)

> backtrack(路径，选择列表){
>     if(满足结束条件){
>         result.add(结果);
>     }
>     for(选择：选择列表){
>         做出选择;
>         backtrack(路径，选择列表);
>         撤销选择;
>     }
> }

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

1 2022.01.13

1 2020.09.18 

#### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

1 2022.01.17

1 2020.09.21 

#### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

1 2022.01.16

1 2020.09.21 

#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

1 2022.01.16

1 2020.09.21 (双指针)

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

1 2022.01.16

1 2020.09.21（双指针）

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

1 2022.01.16（勿用中间ListNode变量）

1 2020.09.22 

#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

1 2022.01.16（勿用中间ListNode变量）

1 2020.09.22 

#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

1 2022.01.16（注意区别于问题：子树问题）

1 2020.09.22 

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

1 2022.01.17（用非递归简单解决）

1 2020.09.22 

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

1 2022.01.17

1 2020.09.22 

#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

1 2022.01.17

1 2022.01.06（和leetcode 54一致）

1 2020.09.23 

#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

1 2022.01.17

1 2020.09.23 

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

1 2022.01.17

1 2020.09.23 

#### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

1 2022.01.17

1 2020.09.23 

#### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

1 2022.01.17

1 2020.09.23 

#### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

1 2022.01.17

1 2020.09.23 

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

1 2022.01.17（非递归难理解）

1 2020.09.24 

#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

1 2022.01.17

1 2020.09.24 

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

1 2022.01.18（两种思路）

1 2020.09.24 

#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

1 2022.01.18

1 2020.09.24 

#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

1 2022.01.18

1 2020.09.24 

#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

1 2022.01.17

1 2020.09.25

#### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

1 2022.01.17

1 2020.09.26

#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

1 2022.01.19（大小顶堆）

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

1 2022.01.19

#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

ing

1 2020.09.28

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

1 2022.01.19（需分析递推公式）

1 2020.09.28

#### [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

1 2022.01.19

1 2020.09.28

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

ing

#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

1 2022.01.20

1 2020.09.28

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

1 2022.01.20

1 2020.09.28

#### [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

1 2022.01.20

1 2020.09.28

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

1 2022.01.20

1 2020.09.29

#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

1 2022.01.20

1 2020.05.14

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

ing

1 2020.09.29

#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

1 2022.01.20（找递推公式）

1 2020.09.29

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

1 2022.01.20（同样找递推公式）

1 2020.09.29

#### [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

1 2022.01.20

1 2020.09.29

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

1 2022.01.21

1 2020.09.29

#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

1 2022.01.21

1 2020.09.30

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

1 2022.01.21（尝试递归）

1 2020.09.30

#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

1 2022.01.21（边界条件没有想清楚）

1 2020.09.30



1. 矩形覆盖

   https://blog.csdn.net/weixin_40668866/article/details/104683512



## 7. References

- [二叉树基础](https://www.jianshu.com/p/bf73c8d50dc2)
- [Leetcode——二叉树常考算法整理](https://blog.csdn.net/qq_32690999/article/details/80484440)
- [数据结构与算法——平衡二叉树](https://xiaozhuanlan.com/topic/2937850641)
- [二叉查找树、平衡二叉树、红黑树、B-/B+树性能对比](https://blog.csdn.net/z702143700/article/details/49079107)
- [递归的定义](https://blog.csdn.net/tianping168/article/details/2493335)

## 待做题目

最长重复子序列

给一个数组 A = [2, 4, 8, 3] 输出一个数组 B，其中 B[i] 值为 A 中小于 A[i] 的元素值之和，B 应该为 [0, 5, 9, 2]（小于 2 的有 [0]，小于 4 的有 [2, 3] ...）

二叉树直径，LeetCode 543

牛妹在练习打字，现在按照时间顺序给出牛妹按下的键（以字符串形式给出, '<' 代表回退 backspace，其余字符均是牛妹打的字符，字符只包含小写字母与 '<'），牛妹想知道最后在屏幕上显示的文本内容是什么

在这个特殊的假期里，由于牛牛在家特别无聊，于是他发明了一个小游戏，游戏规则为：将字符串数字中为偶数位的数字进行翻转，将翻转后的结果进行输出。（头尾双指针)

牛牛有一个 n 个数字的序列，现在牛牛想把这个序列分成 k 段连续段，牛牛想知道分出来的 k 个连续段的段内数字和的最小值最大可以是多少？（我用的递归，似乎大数据过不了，应该考虑尾递归或者用个 Map 存一下已经计算过的片段值）
